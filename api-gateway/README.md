# API Gateway - Spring Cloud Gateway

This is a professional API Gateway implementation using Spring Cloud Gateway with JWT-based authentication, role-based authorization, and service discovery via Eureka.

## Features

✅ **JWT Token Validation** - Validates access tokens from auth-service
✅ **Role-Based Authorization** - Supports USER, VENDOR, ADMIN, MANAGER roles
✅ **Service Discovery** - Integrates with Eureka for dynamic service routing
✅ **Route Management** - Pre-configured routes for auth-service and user-service
✅ **CORS Configuration** - Proper CORS setup for frontend applications
✅ **Request Enrichment** - Adds user context headers for downstream services
✅ **Centralized Error Handling** - Consistent error response format
✅ **Reactive Architecture** - Built on Spring WebFlux for high performance

## Tech Stack

- **Spring Boot 4.0.2** (Java 21)
- **Spring Cloud Gateway** - API Gateway
- **Eureka Client** - Service discovery
- **JWT (JJWT 0.12.6)** - Token validation
- **Lombok** - Boilerplate reduction

## Architecture

### Gateway Flow

```
Client Request → API Gateway → Authentication Filter → Role Authorization Filter → Downstream Service
```

### Components

1. **AuthenticationFilter**: Validates JWT tokens and extracts user information
2. **RoleAuthorizationFilter**: Checks if user has required role(s) for the route
3. **JwtUtil**: Utility class for JWT token parsing and validation
4. **CorsConfig**: CORS configuration for cross-origin requests
5. **GlobalErrorAttributes**: Consistent error response formatting

## Route Configuration

### Public Routes (No Authentication)

#### Auth Service - `/auth/**`
All authentication endpoints are public and don't require authentication:
- `POST /auth/register` - User registration
- `POST /auth/login` - User login
- `POST /auth/verify-email?token={token}` - Email verification
- `POST /auth/resend-verification` - Resend verification email
- `POST /auth/refresh-token` - Refresh access token
- `POST /auth/forgot-password` - Request password reset
- `POST /auth/reset-password` - Reset password with token

**Example:**
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "SecurePass123"
  }'
```

### Protected Routes (Authentication Required)

#### User Service - `/api/users/**`
**Allowed Roles:** USER, VENDOR, ADMIN, MANAGER (All authenticated users)

**Example:**
```bash
curl -X GET http://localhost:8080/api/users/profile \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

#### Admin Routes - `/api/admin/**`
**Allowed Roles:** ADMIN only

**Example:**
```bash
curl -X GET http://localhost:8080/api/admin/users \
  -H "Authorization: Bearer YOUR_ADMIN_ACCESS_TOKEN"
```

#### Vendor Routes - `/api/vendor/**`
**Allowed Roles:** VENDOR, ADMIN, MANAGER

**Example:**
```bash
curl -X GET http://localhost:8080/api/vendor/products \
  -H "Authorization: Bearer YOUR_VENDOR_ACCESS_TOKEN"
```

#### Manager Routes - `/api/manager/**`
**Allowed Roles:** MANAGER, ADMIN

**Example:**
```bash
curl -X GET http://localhost:8080/api/manager/reports \
  -H "Authorization: Bearer YOUR_MANAGER_ACCESS_TOKEN"
```

## Authentication

The API Gateway validates JWT access tokens generated by the auth-service.

### Token Format

```
Authorization: Bearer <access_token>
```

### Token Validation

1. Check if Authorization header is present
2. Verify "Bearer " prefix
3. Extract and validate JWT token
4. Check token expiration
5. Extract user information (userId, email, username, role)

### Request Enrichment

After successful authentication, the gateway adds the following headers to downstream requests:

```
X-User-Id: <user_uuid>
X-User-Email: <user_email>
X-User-Username: <username>
X-User-Role: <user_role>
```

Downstream services can use these headers to identify the authenticated user without re-validating the token.

## Role-Based Authorization

### Role Hierarchy

- **USER**: Basic user access
- **VENDOR**: Business/seller access
- **MANAGER**: Management access
- **ADMIN**: Full administrative access

### Authorization Logic

The `RoleAuthorizationFilter` checks if the user's role matches any of the allowed roles for a route:

```yaml
- name: RoleAuthorizationFilter
  args:
    roles: ADMIN,MANAGER  # User must have ADMIN OR MANAGER role
```

## Error Responses

All errors follow a consistent format:

### 401 Unauthorized - Authentication Failed
```json
{
  "timestamp": "2026-01-27T10:30:00",
  "status": 401,
  "message": "Missing authorization header"
}
```

### 403 Forbidden - Authorization Failed
```json
{
  "timestamp": "2026-01-27T10:30:00",
  "status": 403,
  "message": "Access denied. Required roles: ADMIN. Your role: USER"
}
```

### 404 Not Found - Service Not Available
```json
{
  "timestamp": "2026-01-27T10:30:00",
  "status": 404,
  "message": "Service not found"
}
```

### 503 Service Unavailable
```json
{
  "timestamp": "2026-01-27T10:30:00",
  "status": 503,
  "message": "Service temporarily unavailable"
}
```

## Configuration

### application.yaml

```yaml
server:
  port: 8080

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # Routes configuration
      globalcors:
        # CORS configuration

jwt:
  secret: <must-match-auth-service-secret>

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

## CORS Configuration

The gateway is configured to accept requests from:
- `http://localhost:3000` (React default)
- `http://localhost:5173` (Vite default)

Allowed methods:
- GET, POST, PUT, DELETE, PATCH, OPTIONS

Allowed headers: All (`*`)

Credentials: Enabled

## Setup Instructions

### Prerequisites

- Java 21
- Maven
- Eureka Server running on port 8761
- Auth Service running on port 8081

### 1. Configure JWT Secret

**IMPORTANT**: The JWT secret in the API Gateway **must match** the secret in the auth-service.

Update `application.yaml`:
```yaml
jwt:
  secret: <same-secret-as-auth-service>
```

### 2. Build the Project

```bash
cd api-gateway
mvnw clean install
```

### 3. Run the Gateway

```bash
mvnw spring-boot:run
```

Or run the JAR:
```bash
java -jar target/api-gateway-0.0.1-SNAPSHOT.jar
```

The gateway will start on **port 8080** and register with Eureka.

## Testing

### 1. Test Public Route (No Authentication)

```bash
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "SecurePass123"
  }'
```

### 2. Login and Get Token

```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "SecurePass123"
  }'
```

Response:
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "message": "Login successful",
  "success": true
}
```

### 3. Test Protected Route

```bash
# Save the access token
TOKEN="<access_token_from_login>"

# Test user route (all roles allowed)
curl -X GET http://localhost:8080/api/users/profile \
  -H "Authorization: Bearer $TOKEN"

# Test admin route (ADMIN only)
curl -X GET http://localhost:8080/api/admin/users \
  -H "Authorization: Bearer $TOKEN"
```

### 4. Test Authorization Failure

Try accessing an admin route with a USER role token:

```bash
curl -X GET http://localhost:8080/api/admin/users \
  -H "Authorization: Bearer <user_role_token>"
```

Expected response:
```json
{
  "timestamp": "2026-01-27T10:30:00",
  "status": 403,
  "message": "Access denied. Required roles: ADMIN. Your role: USER"
}
```

## Service Discovery

The gateway uses Eureka for service discovery. Services are referenced by their application name:

- `lb://auth-service` → Routes to auth-service instances
- `lb://user-service` → Routes to user-service instances (Node.js)

The `lb://` prefix enables client-side load balancing across multiple instances.

## Adding New Routes

To add a new route, update `application.yaml`:

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: my-new-service
          uri: lb://my-service
          predicates:
            - Path=/api/myservice/**
          filters:
            - RewritePath=/api/myservice/(?<segment>.*), /${segment}
            - name: AuthenticationFilter
            - name: RoleAuthorizationFilter
              args:
                roles: USER,ADMIN
```

## Filter Order

Filters are executed in the following order:

1. **CORS Filter** (Pre-filter)
2. **AuthenticationFilter** (Validates JWT token)
3. **RoleAuthorizationFilter** (Checks user role)
4. **Route to downstream service**

## Monitoring

### Health Check

```bash
curl http://localhost:8080/actuator/health
```

### Gateway Routes

```bash
curl http://localhost:8080/actuator/gateway/routes
```

### Registered Services

Check Eureka dashboard: http://localhost:8761

## Security Best Practices

1. ✅ **JWT Secret Security**: Use strong, randomly generated secret (minimum 256 bits)
2. ✅ **HTTPS in Production**: Always use HTTPS for production
3. ✅ **Token Expiration**: Short-lived access tokens (15 minutes)
4. ✅ **Role-Based Access Control**: Granular control over route access
5. ✅ **CORS Configuration**: Restrict allowed origins in production
6. ✅ **Request Headers**: Sensitive user info only in internal headers
7. ✅ **Error Messages**: Don't expose internal system details
8. ✅ **Service Discovery**: Use Eureka for dynamic service routing

## Production Considerations

### 1. Environment Variables

Use environment variables for sensitive configuration:

```yaml
jwt:
  secret: ${JWT_SECRET}

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_URL:http://localhost:8761/eureka/}
```

### 2. Rate Limiting

Add rate limiting filter:

```java
- name: RequestRateLimiter
  args:
    redis-rate-limiter.replenishRate: 10
    redis-rate-limiter.burstCapacity: 20
```

### 3. Logging

Configure structured logging for production:

```yaml
logging:
  level:
    org.springframework.cloud.gateway: INFO
    com.okkazo.apigateway: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

### 4. Circuit Breaker

Add resilience with circuit breaker:

```yaml
- name: CircuitBreaker
  args:
    name: myCircuitBreaker
    fallbackUri: forward:/fallback
```

### 5. Actuator Security

Secure actuator endpoints in production:

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info
```

### 6. CORS Origins

Restrict CORS origins to your actual frontend domains:

```yaml
allowedOrigins: 
  - "https://yourdomain.com"
  - "https://www.yourdomain.com"
```

## Integration with Node.js User Service

When you implement the user-service in Node.js, ensure:

1. **Service Registration**: Register with Eureka using `eureka-js-client`
2. **Header Reading**: Read `X-User-*` headers for authenticated user info
3. **No Token Validation**: Gateway already validated the token
4. **Service Name**: Use `user-service` as the application name

**Example Node.js code:**

```javascript
app.get('/profile', (req, res) => {
  const userId = req.headers['x-user-id'];
  const userEmail = req.headers['x-user-email'];
  const userRole = req.headers['x-user-role'];
  
  // Use the authenticated user information
  // No need to validate JWT token again
});
```

## Troubleshooting

### Issue: 503 Service Unavailable

**Solution**: Ensure the downstream service is running and registered with Eureka.

```bash
# Check Eureka dashboard
curl http://localhost:8761
```

### Issue: 401 Unauthorized on valid token

**Solution**: Ensure JWT secret matches between gateway and auth-service.

### Issue: CORS errors

**Solution**: Check that your frontend origin is in the allowed origins list.

### Issue: Gateway not registering with Eureka

**Solution**: Check Eureka URL configuration and network connectivity.

```yaml
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

## Contributing

This API Gateway is part of the Okkazo Capstone Project 2026.

## License

MIT License - Feel free to use this in your projects!

## Author

Okkazo Team - Capstone Project 2026
