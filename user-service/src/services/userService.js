const User = require('../models/User');
const logger = require('../utils/logger');
const createApiError = require('../utils/ApiError');

/**
 * Create a new user
 */
const createUser = async (userData) => {
  try {
    if (!userData || Object.keys(userData).length === 0) {
      throw createApiError(400, 'User data is required');
    }

    if (!userData.authId || !userData.email) {
      throw createApiError(400, 'Auth ID and email are required');
    }

    const user = new User(userData);
    await user.save();
    logger.info(`User created: ${user.email}`);
    return user;
  } catch (error) {
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      throw createApiError(409, `User with this ${field} already exists`);
    }
    logger.error('Error creating user:', error);
    throw createApiError(500, 'Error creating user');
  }
};

/**
 * Get user by ID
 */
const getUserById = async (userId) => {
  try {
    if (!userId) {
      throw createApiError(400, 'User ID is required');
    }

    // Check if it's a valid MongoDB ObjectId
    if (!userId.match(/^[0-9a-fA-F]{24}$/)) {
      throw createApiError(400, 'Invalid user ID format');
    }

    const user = await User.findById(userId);
    if (!user) {
      throw createApiError(404, 'User not found');
    }
    return user;
  } catch (error) {
    if (error.statusCode) throw error;
    logger.error('Error fetching user by ID:', error);
    throw createApiError(500, 'Error fetching user');
  }
};

/**
 * Get user by authId
 */
const getUserByAuthId = async (authId) => {
  try {
    if (!authId || authId.trim() === '') {
      throw createApiError(400, 'Auth ID is required');
    }

    const user = await User.findOne({ authId: authId.trim() });
    if (!user) {
      throw createApiError(404, 'User not found');
    }
    return user;
  } catch (error) {
    if (error.statusCode) throw error;
    logger.error('Error fetching user by authId:', error);
    throw createApiError(500, 'Error fetching user');
  }
};

/**
 * Get user by email
 */
const getUserByEmail = async (email) => {
  try {
    if (!email || email.trim() === '') {
      throw createApiError(400, 'Email is required');
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw createApiError(400, 'Invalid email format');
    }

    const user = await User.findOne({ email: email.toLowerCase().trim() });
    if (!user) {
      throw createApiError(404, 'User not found');
    }
    return user;
  } catch (error) {
    if (error.statusCode) throw error;
    logger.error('Error fetching user by email:', error);
    throw createApiError(500, 'Error fetching user');
  }
};

/**
 * Update user profile
 */
const updateUser = async (userId, updateData) => {
  try {
    // Remove fields that shouldn't be updated directly
    const { authId, role, memberSince, createdAt, updatedAt, ...allowedUpdates } =
      updateData;

    const user = await User.findById(userId);
    if (!user) {
      throw createApiError(404, 'User not found');
    }

    Object.assign(user, allowedUpdates);
    
    // Update profile completion status
    user.updateProfileCompletion();
    
    await user.save();
    logger.info(`User updated: ${user.email}`);
    return user;
  } catch (error) {
    if (error.statusCode) throw error;
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      throw createApiError(409, `User with this ${field} already exists`);
    }
    logger.error('Error updating user:', error);
    throw createApiError(500, 'Error updating user');
  }
};

/**
 * Delete user (soft delete)
 */
const deleteUser = async (userId) => {
  try {
    const user = await User.findById(userId);
    if (!user) {
      throw createApiError(404, 'User not found');
    }

    user.isActive = false;
    await user.save();
    logger.info(`User deactivated: ${user.email}`);
    return { message: 'User deactivated successfully' };
  } catch (error) {
    if (error.statusCode) throw error;
    logger.error('Error deleting user:', error);
    throw createApiError(500, 'Error deleting user');
  }
};

/**
 * Get all users with pagination and filters
 */
const getAllUsers = async (filters = {}, page = 1, limit = 10) => {
  try {
    const query = { isActive: true };

    if (filters.role) {
      query.role = filters.role.toUpperCase();
    }

    if (filters.profileIsComplete !== undefined) {
      query.profileIsComplete = filters.profileIsComplete === 'true';
    }

    if (filters.search) {
      query.$or = [
        { name: new RegExp(filters.search, 'i') },
        { fullName: new RegExp(filters.search, 'i') },
        { email: new RegExp(filters.search, 'i') },
      ];
    }

    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      User.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(Number(limit))
        .lean(),
      User.countDocuments(query),
    ]);

    return {
      users,
      pagination: {
        currentPage: Number(page),
        totalPages: Math.ceil(total / limit),
        totalUsers: total,
        limit: Number(limit),
      },
    };
  } catch (error) {
    logger.error('Error fetching users:', error);
    throw createApiError(500, 'Error fetching users');
  }
};

/**
 * Update user's last login timestamp
 */
const updateLastLogin = async (authId) => {
  try {
    if (!authId || authId.trim() === '') {
      throw createApiError(400, 'Auth ID is required');
    }

    const user = await User.findOneAndUpdate(
      { authId: authId.trim() },
      { lastLogin: new Date() },
      { new: true }
    );

    if (!user) {
      logger.warn(`User not found for lastLogin update: ${authId}`);
      throw createApiError(404, 'User not found');
    }

    logger.info(`Last login updated for user: ${user.email}`);
    return user;
  } catch (error) {
    if (error.statusCode) throw error;
    logger.error('Error updating last login:', error);
    throw createApiError(500, 'Error updating last login');
  }
};

/**
 * Get user statistics
 */
const getUserStats = async () => {
  try {
    const [totalUsers, activeUsers, byRole, completedProfiles] = await Promise.all([
      User.countDocuments(),
      User.countDocuments({ isActive: true }),
      User.aggregate([
        { $group: { _id: '$role', count: { $sum: 1 } } },
      ]),
      User.countDocuments({ profileIsComplete: true }),
    ]);

    return {
      totalUsers,
      activeUsers,
      inactiveUsers: totalUsers - activeUsers,
      completedProfiles,
      incompleteProfiles: totalUsers - completedProfiles,
      byRole: byRole.reduce((acc, item) => {
        acc[item._id] = item.count;
        return acc;
      }, {}),
    };
  } catch (error) {
    logger.error('Error fetching user stats:', error);
    throw createApiError(500, 'Error fetching user statistics');
  }
};

module.exports = {
  createUser,
  getUserById,
  getUserByAuthId,
  getUserByEmail,
  updateUser,
  deleteUser,
  getAllUsers,
  updateLastLogin,
  getUserStats,
};
